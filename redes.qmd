---
title: "Redes neuronales"
jupyter: python3
echo: false
output: false
---

## ***Exportaciones***

```{python}
import tensorflow as tf
from tensorflow.keras.callbacks import CSVLogger, EarlyStopping
import matplotlib as mpl
import matplotlib.pyplot as plt
import numpy as np
import os
import pandas as pd
import seaborn as sns
import time
import gc
import sys
from statsmodels.graphics.tsaplots import plot_acf
from statsmodels.graphics.tsaplots import plot_pacf

print(f"Tensorflow Version: {tf.__version__}")
print(f"Pandas Version: {pd.__version__}")
print(f"Numpy Version: {np.__version__}")
print(f"System Version: {sys.version}")

mpl.rcParams['figure.figsize'] = (17, 5)
mpl.rcParams['axes.grid'] = False
sns.set_style("whitegrid")

notebookstart= time.time()
```

```{python}
import IPython
import IPython.display
```

### Datos

Total de Exportaciones **Colombia** desde enero del año 2000 hasta junio del año 2023.

```{python}
#| output: true

# Lectura de la serie
Exportaciones = pd.read_excel("datos/Exportaciones.xlsx",
                   header = 0, usecols = ['Mes','Total']).iloc[96:].reset_index(drop = True).round()
Exportaciones['Total'] = Exportaciones['Total'].astype(int) 
Exportaciones
```

<br>

### Predicción univariada

Se quiere predecir la variable "Total de Exportaciones" (**Total**) en base a sus retardos. <br>
A continuación se presenta el gráfico de la serie de tiempo:


```{python}
features_considered = ['Total'] # la variable a usar en la predicción es ella misma
features = Exportaciones[features_considered] # solo se usará la variable Total en la predicción
features.index = Exportaciones['Mes'] # variable que indica el tiempo (la serie es mensual)
features.head()
```


```{python}
#| output: true

features.plot(subplots = True, ) # gráfico de la serie de tiempo
```

<br>

### Separación (Entrenamiento-Validación-Prueba) y Normalización.

El conjunto de datos original se divide en tres partes, de la siguiente manera:

- Datos de entrenamiento (**70%**) para un total de **197** observaciones. Desde 2000-01 hasta 2016-05.
- Datos de validación (**20%**) para un total de **56** observaciones. Desde 2016-06 hasta 2021-01.
- Datos de entrenamiento (**10%**) para un total de **29** observaciones. Desde 2021-02 hasta 2023-06.

```{python}
# partición del conjuntos de datos en entrenamiento, validación y prueba
column_indices = {name: i for i, name in enumerate(features.columns)} # índice = 0

n = len(features) # longitud de la serie (282)
train_df = features[0:int(n*0.7)] # 2000-01 hasta 2016-05
val_df = features[int(n*0.7):int(n*0.9)] # 2016-06 hasta 2021-01
test_df = features[int(n*0.9):] # 2021-02 hasta 2023-06

num_features = features.shape[1]
```

```{python}
print("longitud dataframe entrenamiento:", train_df.shape)
print("longitud dataframe validación:", val_df.shape)
print("longitud dataframe prueba:", test_df.shape)
```

```{python}
# Normalización de las observaciones
train_mean = train_df.mean()
train_std = train_df.std()

train_df = (train_df - train_mean) / train_std
val_df = (val_df - train_mean) / train_std
test_df = (test_df - train_mean) / train_std
```

```{python}
# todo el dataframe normalizado por train_mean y train_std
df_std = (features - train_mean) / train_std
df_std = df_std.melt(var_name='', value_name='Datos normalizados')
df_std
```

```{python}
#| output: true
#| fig-align: center

# plt.subplot(1, 2, 1)
# sns.violinplot(y=Exportaciones["Total"])

plt.figure(figsize=(12, 8))
ax = sns.violinplot(x = '', y = 'Datos normalizados', data = df_std)
_ = ax.set_xticklabels(features.keys(), rotation=0)
```

```{python}
class WindowGenerator():
  def __init__(self, input_width, label_width, shift,
               train_df=train_df, val_df=val_df, test_df=test_df,
               label_columns=None):
    # Store the raw data.
    self.train_df = train_df
    self.val_df = val_df
    self.test_df = test_df

    # Work out the label column indices.
    self.label_columns = label_columns
    if label_columns is not None:
      self.label_columns_indices = {name: i for i, name in
                                    enumerate(label_columns)}
    self.column_indices = {name: i for i, name in
                           enumerate(train_df.columns)}

    # Work out the window parameters.
    self.input_width = input_width
    self.label_width = label_width
    self.shift = shift

    self.total_window_size = input_width + shift

    self.input_slice = slice(0, input_width)
    self.input_indices = np.arange(self.total_window_size)[self.input_slice]

    self.label_start = self.total_window_size - self.label_width
    self.labels_slice = slice(self.label_start, None)
    self.label_indices = np.arange(self.total_window_size)[self.labels_slice]

  def __repr__(self):
    return '\n'.join([
        f'Total window size: {self.total_window_size}',
        f'Input indices: {self.input_indices}',
        f'Label indices: {self.label_indices}',
        f'Label column name(s): {self.label_columns}'])
```

```{python}
def split_window(self, features):
  inputs = features[:, self.input_slice, :]
  labels = features[:, self.labels_slice, :]
  if self.label_columns is not None:
    labels = tf.stack(
        [labels[:, :, self.column_indices[name]] for name in self.label_columns],
        axis=-1)

  # Slicing doesn't preserve static shape information, so set the shapes
  # manually. This way the `tf.data.Datasets` are easier to inspect.
  inputs.set_shape([None, self.input_width, None])
  labels.set_shape([None, self.label_width, None])

  return inputs, labels

WindowGenerator.split_window = split_window
```

```{python}
def make_dataset(self, data):
  data = np.array(data, dtype=np.float32)
  ds = tf.keras.utils.timeseries_dataset_from_array(
      data=data,
      targets=None,
      sequence_length=self.total_window_size,
      sequence_stride=1,
      shuffle=False,
      batch_size=32,) 

  ds = ds.map(self.split_window)

  return ds

WindowGenerator.make_dataset = make_dataset
```

```{python}
@property
def train(self):
  return self.make_dataset(self.train_df)

@property
def val(self):
  return self.make_dataset(self.val_df)

@property
def test(self):
  return self.make_dataset(self.test_df)

@property
def example(self):
  """Get and cache an example batch of `inputs, labels` for plotting."""
  result = getattr(self, '_example', None)
  if result is None:
    # No example batch was found, so get one from the `.train` dataset
    result = next(iter(self.train))
    # And cache it for next time
    self._example = result
  return result

WindowGenerator.train = train
WindowGenerator.val = val
WindowGenerator.test = test
WindowGenerator.example = example
```

```{python}
def plot(self, model=None, plot_col='Total', max_subplots=3):
  inputs, labels = self.example
  plt.figure(figsize=(12, 8))
  plot_col_index = self.column_indices[plot_col]
  max_n = min(max_subplots, len(inputs))
  for n in range(max_n):
    plt.subplot(max_n, 1, n+1)
    plt.ylabel(f'{plot_col} [normed]')
    plt.plot(self.input_indices, inputs[n, :, plot_col_index],
             label='Inputs', marker='.', zorder=-10)

    if self.label_columns:
      label_col_index = self.label_columns_indices.get(plot_col, None)
    else:
      label_col_index = plot_col_index

    if label_col_index is None:
      continue

    plt.scatter(self.label_indices, labels[n, :, label_col_index],
                edgecolors='k', label='Labels', c='#2ca02c', s=64)
    if model is not None:
      predictions = model(inputs)
      plt.scatter(self.label_indices, predictions[n, :, label_col_index],
                  marker='X', edgecolors='k', label='Predictions',
                  c='#ff7f0e', s=64)

    if n == 0:
      plt.legend()

  plt.xlabel('Time [h]')

WindowGenerator.plot = plot
```

```{python}
# Definimos número de épocas necesarias y funciones de pérdida
MAX_EPOCHS = 200

def compile_and_fit(model, window, patience=2): #patiences como el número de épocas que espera antes de parar
  # Para evitar sobreajuste
  early_stopping = tf.keras.callbacks.EarlyStopping(monitor='val_loss',
                                                    patience=patience,
                                                    mode='min')

  model.compile(loss=tf.losses.MeanSquaredError(),
                optimizer=tf.optimizers.Adam(),
                metrics=[tf.metrics.MeanAbsoluteError()])

  history = model.fit(window.train, epochs=MAX_EPOCHS,
                      validation_data=window.val,
                      callbacks=[early_stopping])
  return history
```

<br>

### Configuración para el ajuste de los modelos

- Se usará un tamaño de lote de **32**.
- El número máximo de épocas será de **20**.

```{python}

```
