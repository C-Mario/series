---
title: "Descriptiva-josé"
author: "Jose Valdes"
lag: es
format: html
editor_options: 
  chunk_output_type: console
---

```{r}
#| include: false
library(tidyverse)
library(lubridate)
library(timetk)
library(tibble)
library(zoo)
library(fable)
library(tsibble)
library(feasts)
```

# Trabajo con la serie Bitcoin

```{r}
#datos
BTC_Daily <- read.csv("datos/BTC-Daily.csv")
Data <- data.frame(BTC_Daily$date,BTC_Daily$close)
Data <- data.frame(BTC_Daily$date,BTC_Daily$close)
colnames(Data) <- c("FechaTiempo", "Valor")
# limpiando datos faltantes
str(Data)
Data$FechaTiempo <- strftime(Data$FechaTiempo, format="%Y-%m-%d")
str(Data)
Data$FechaTiempo <- as.Date(Data$FechaTiempo)
# procesamiento de los datos

Bitcoin <- Data %>%
      filter(FechaTiempo >= as.Date("2017-01-01"),
             FechaTiempo <= as.Date("2021-12-31"))
str(Bitcoin)
```

### Probando xts

```{r}
# objeto serie de tiempo
Data_xts <- xts::xts(Bitcoin$Valor, order.by = Bitcoin$FechaTiempo)
head(Data_xts)
TSstudio::ts_info(Data_xts)
class(Data_xts)
frequency(Data_xts)
xts::periodicity(Data_xts)
xts::tclass(Data_xts)
plot(Data_xts)
```

Vista de los datos para inspección visual

```{r}
#TSstudio::ts_plot(Data_xts,
 #         title = "Valor de cierre bitcoin en bolsa",
  #        Ytitle = "Valor en dolares",
   #        Xtitle = "Fecha",
    #       Xgrid = TRUE,
     #   Ygrid = TRUE)
```

-   **Varianza marginal:** Se notan periodos donde el rango de valores que puede tomar la variable se va haciendo mayor.

-   **Componente Estacional:** No se tiene evidencia clara de un comportamiento cíclico en la serie.

-   **Tendencia:** Se muestra la serie **no** oscila sobre un valor fijo y tiene cambios abruptos de crecimiento y decrecimiento en algunos momentos.

### Análisis de varianza

Usaremos la transformación de **Box-Cox** para estabilizar la varianza; primero miramos el lambda

```{r}
#Valor de lambda
forecast::BoxCox.lambda(Data_xts, method ="loglik", lower = -1, upper = 3)
MASS::boxcox(lm(Data_xts ~ 1),seq(-1/2, 1/2, length = 50))
```

Vemos que se sugiere el valor $\lambda = 0$ lo cual suguiere usar la función logaritmo natural para la trasformación así tenemos que:

```{r}
#trasnformación
lData_xts <- log(Data_xts)
plot(lData_xts)
```

```{r}
#| output: true
#TSstudio::ts_plot(lData_xts,
 #         title = "Valor de Serie Trasnformada",
  #         Ytitle = "Valor de la trasnformación",
   #       Xtitle = "Fecha",
    #      Xgrid = TRUE,
     #      Ygrid = TRUE)
```

Ahora miramos si es necesario aplicar otra transformación a la serie

```{r}
#Valor de lambda
forecast::BoxCox.lambda(lData_xts, method ="loglik", lower = -1, upper = 3)
MASS::boxcox(lm(lData_xts ~ 1),seq(-1, 2, length = 50))
```

Vemos que la sugerencia es $\lambda = 0.9$ lo cual es cercano a $1$, además el IC de confianza captura al $1$, por ende la transformación logarítmica parece haber estabilizado la varianza.

### Análisis de tendencia

Trabajaremos a la cuál se le realizo la transformación para estabilizar la varianza, realizaremos el gráfico de los valores de la función de auto-correalción

```{r}
#ACf
acf(lData_xts, 90, main = "Serie Bitcoin Trasnformada")
```

Notamos que los van teniendo un decaimiento leve lo cual nos da un indicio más claro de que existe tendencia en la serie así usaremos los métodos: *lineal determinista, Descomposición de* *promedios móviles y descomposición STL* para estimar dicha componente.

```{r}
#pacf
pacf(lData_xts, 90, main = "Serie Bitcoin Trasnformada")
```

#### Lineal determinista

ajustaremos el modelo eliminaremos la tendencia y analizaremos los resultados

```{r}
#pasar a ts para poder hacerlo
ldata_ts <- TSstudio::xts_to_ts(lData_xts,frequency = 365,
                                start = as.Date("2017-01-01"))
#modelo lineal
summary(fit <- lm(ldata_ts~time(ldata_ts), na.action=NULL))
```

```{r}
# Gráfico
plot(ldata_ts, ylab= "Valor en escala logarítmica")
abline(fit,col = "red")# Se añade la recta ajusta
```

ahora eliminaremos la tendencia de la serie

```{r}
###Eliminamos la tendencia con la predicción la recta
ElimTenldata_ts <- ldata_ts - predict(fit)
plot(ElimTenldata_ts, main="Serie Sin tendencia", 
     ylab= "Valor en escala logarítmica")
acf(ElimTenldata_ts,lag.max =length(ElimTenldata_ts), 
    main="Serie Sin tendencia")
```

pacf(ElimTenldata_ts,lag.max =length(ElimTenldata_ts))

Observamos que en la serie obtenida después de eliminar la tendencia lineal en el sigue teniendo un decaimiento lento de los valores de la función de auto-correlación para rezagos algunos rezagos dando indicios de un componente estacional

#### Descomposición por promedio móviles

```{r}
# descomposición de promedios moviles
descom_ldata <- decompose(ldata_ts)
plot(descom_ldata)
```

Podemos observar que usando **un filtro de promedio móvil** la tendencia estimada no se aproxima mucho a una lineal, cómo se puede apreciar en el siguiente gráfico; además la componente estacional no parece ser estimada de buena manera y el residual aún presenta patrones estacionales.

```{r}
# Gráfico
plot(ldata_ts, ylab= "Valor en escala logarítmica")
abline(fit,col = "red")# Se añade la recta ajusta
points(time(ldata_ts), descom_ldata$trend, col ="green", cex=0.3)

```

Eliminaremos la tendencia del promedio móvil centrado y de la frecuencia

```{r}
###Eliminamos la tendencia con la predicción promedio movil
ElimTenldata_ts <- ldata_ts - descom_ldata$trend
plot(ElimTenldata_ts, main="Serie Sin tendencia", 
     ylab= "Valor en escala logarítmica")
```

***Filtro promedio móvil con solo retrasos***

Intentaremos ajustar un promedio móvil que tenga en cuenta solo los retrasos y sea de los periodos de un año, seis meses, tres meses y mes.

```{r}
#gráfico
filter_1=stats::filter(ldata_ts, filter = rep(1/365, 365), sides = 1)
filter_2=stats::filter(ldata_ts, filter = rep(1/182, 182), sides = 1)
filter_3=stats::filter(ldata_ts, filter = rep(1/90, 90), sides = 1)
filter_4=stats::filter(ldata_ts, filter = rep(1/30, 30), sides = 1)
plot(ldata_ts, ylab= "Valor en escala logarítmica")
points(time(ldata_ts), filter_1, col ="green", cex=0.33)
points(time(ldata_ts), filter_2, col ="blue", cex=0.33)
points(time(ldata_ts), filter_3, col ="red", cex=0.35)
points(time(ldata_ts), filter_4, col ="cyan", cex=0.31)
#legend(locator(1), c("365 días","182 días","90 días","30 días"), col=c("green","blue","red","cyan"),lty=c(1,1,1,1),lwd=c(2,2,2,2))
```

Notamos que para *3 meses* el filtro de promedios móviles muestra una mejor suavizamiento de la serie así la tomaremos como una estimación de la tendencia

```{r}
###Eliminamos la tendencia con la predicción promedio movil
ElimTenldata_ts <- ldata_ts - filter_3
plot(ElimTenldata_ts, main="Serie Sin tendencia", 
     ylab= "Valor en escala logarítmica")
acf(ElimTenldata_ts[90:1826],lag.max =length(ElimTenldata_ts), 
    main="Serie Sin tendencia")
```

El problema con esta forma es que los primero 90 días son totalmente descartados pues no se tiene una estimación de la tendencia para esos días con este método

#### Descomposición STL

Usando la descomposición **STL** obtenemos la estimación de la tendencia

```{r}
indice_ldata <- sort(Bitcoin$FechaTiempo)
#  as.Date(as.yearmon(tk_index(ldata_ts)))
## Otra forma de extraer el indice estimetk::tk_index(lAirPass)
logdata <- as.matrix(ldata_ts)
df_ldata <- data.frame(Fecha=indice_ldata,logdata=as.matrix(ldata_ts))
str(df_ldata)
colnames(df_ldata) <- c("Fecha", "logdata")
str(df_ldata)
tibble_ldata <- tibble(df_ldata)
####Primera aproximación del ajuste STL
tibble_ldata%>%timetk::plot_time_series(Fecha, logdata, 
                   .interactive = TRUE,
                   .plotly_slider = TRUE)
```

```{r}
#####Ajuste STL
#Note que obtenemos un objeto adicional en tibble_logpasajeros con Logpasa_ajus con parámetros que se pueden mover.
logdata_ajus <- smooth_vec(logdata,span = 0.75, degree = 2)
tibble_ldata%>%dplyr::mutate(logdata_ajus)
###Ajuste STL moviendo los parámetros
tibble_ldata%>%mutate(logdata_ajus=smooth_vec(logdata,span = 0.75, degree = 2))%>%
  ggplot(aes(Fecha, logdata)) +
    geom_line() +
    geom_line(aes(y = logdata_ajus), color = "red")
```

Ahora con esta estimación eliminaremos la tendencia

```{r}
###Eliminamos la tendencia con la predicción la recta xts
ElimTenldata_xts <- lData_xts - logdata_ajus
plot(ElimTenldata_xts, main="Serie Sin tendencia", 
     ylab= "Valor en escala logarítmica")
acf(ElimTenldata_xts,lag.max =length(ElimTenldata_xts), 
    main="Serie Sin tendencia")
```

```{r}
###Eliminamos la tendencia con la predicción la recta xts
ElimTenldata_ts <- ldata_ts - logdata_ajus
plot(ElimTenldata_ts, main="Serie Sin tendencia", 
     ylab= "Valor en escala logarítmica")
acf(ElimTenldata_ts,lag.max =length(ElimTenldata_xts), 
    main="Serie Sin tendencia")

```

Vemos que a diferencia de los promedio móviles si tenemos una estimación para todos los valores de la serie, además notamos que la función de auto-correlación tiene un decaimiento leve y denota como un patrón dándonos indicios de una posible componente estacional.

## Serie Diferenciada

```{r}
###Diferenciando con base en el objeto ts
dldata<-diff(ldata_ts)
plot(dldata)
abline(h=0, col = "red")
acf(dldata,lag.max =90, main="Serie Diferenciada")
```

```{r}
###Diferenciando con base en el objeto xts
dldata_xts<-diff(lData_xts)
dldata_xts <- dldata_xts[-1]
plot(dldata_xts)
acf(dldata_xts,lag.max =90, main="Serie Diferenciada")
```

Vemos que la serie al ser diferenciada muestra un comportamiento estacionario pues los valores oscilan sobre un valor fijo, además en la gráfica de la función de auto-correlación los valores no superan el umbral, por ende no se tiene relación lineal con los retrasos.

## Gráfica de retardos

Haremos una gráfica de retardos con el valor actual para ver si existe podemos tener indicios relación *no-lineal.*

```{r}
#serie transformada
par(mar = c(3,2,3,2))
astsa::lag1.plot(lData_xts, 16,corr=F)
```

Notamos que para todos los retrados se evidencia que para todos los rezagos se tiene una fuerte correlación lineal con el valor actual

```{r}
# Series trasnfromada sin tendencia STL
par(mar = c(3,2,3,2))
astsa::lag1.plot(ElimTenldata_xts, 16,corr=F)
```

Para la serie sin tendencia seguimos viendo en todos los retardos una fuerte asociación lineal, a pesar de que la componente de tendencia fue eliminada lo cual empieza a darnos indicios de que el comportamiento de nuestra serie podría ser determinado por una *caminata aleatoria* pues parece no cambiar su estructura con los métodos usuales para una lidiar *tendencias deterministas*

```{r}
#serie trasnfromada difereniada
par(mar = c(3,2,3,2))
astsa::lag1.plot(dldata, 16,corr=T)
```

Observamos que para la **serie diferenciada** la relación lineal que mostraban todos los retardos ahora es inexistente todos los retardos se ven no correlacionados; lo cual da otro indicio de que la serie podría tratarse de una caminata aleatoria pues la diferenciación es un buen método para eliminar *tendencias estocásticas.*

## AMI

Usaremos el **índice AMI** el cual nos da información acerca de que tanto conocimiento podemos tener una variable aleatoria con otras para nuestro caso que tanto podemos saber de $X_{t+d}$ al observar $X_t$ .

```{r}
#serie transformada
tseriesChaos::mutual(lData_xts, partitions = 50, lag.max = 100, plot=TRUE)
# Series trasnfromada sin tendencia STL
tseriesChaos::mutual(ElimTenldata_xts, partitions = 50, lag.max = 100, plot=TRUE)
```

Vemos que cómo en el caso anterior no hay gran diferencia entre la serie con y sin 4tendencia, además vemos un decaimiento lento del **índice AMI** para los primeros rezagos

```{r}
#serie trasnfromada difereniada
tseriesChaos::mutual(dldata, partitions = 50, lag.max = 100, plot=TRUE)
```

Notamos cómo para la serie diferenciada los valores son bastante cercanos a $0$ para los rezagos mas cercanos; así con esto y la información dada por las anteriores gráficas las sospechas de que la series se pueda modelar por medio de un caminata aleatoria se hacen más fuertes.

## Análisis de Estacionalidad

### Mapas de calor

```{r}
#Tendencia eliminada
TSstudio::ts_heatmap(ElimTenldata_xts, title = "Mapa de calor - Cierre Bitcoin en bolsa semana año")
#
TSstudio::ts_heatmap(ElimTenldata_ts, title = "Mapa de calor - Cierre Bitcoin en bolsa dias año")
```

Notamos que para la serie con la tendencia elimindad con STL con el mapa de calor parece que no existir patrón semanal a medida que transcurre el año y tampoco existir un patrón semanal en el transcurrir del año.

```{r}
#Serie diferenciada
TSstudio::ts_heatmap(dldata_xts, title = "Mapa de calor - Cierre Bitcoin en bolsa dias año")
```

Para la serie diferenciada no se evidencia ninguno tipo de patrón.

### Periodograma

```{r}
# periodograma
Periodograma <- spectrum(as.numeric(ElimTenldata_xts),log="no",span=c(5,5))
#
ubicacionElim <- which.max(Periodograma$spec)
sprintf("El valor de la frecuencia donde se máximiza el periodograma para la serie es: %s",Periodograma$freq[ubicacionElim])
#
sprintf("El periodo correspondiente es aproximadamente: %s",1/Periodograma$freq[ubicacionElim])
```

Para la serie donde se elimina la tendencia con STL el periodograma nos da un valor de $\omega = \frac{1}{625} = 0.0016$ lo que se corresponde son un periodo $s = 625$ lo cual corresponde a casi dos años. Es de destacar que el valor de la frecuencia es cercano a cero.

```{r}
# periodograma
Periodograma <- spectrum(as.numeric(dldata_xts),log="no",span=c(5,5))
#
ubicacionDif <- which.max(Periodograma$spec)
sprintf("El valor de la frecuencia donde se máximiza el periodograma para la serie es: %s",Periodograma$freq[ubicacionDif])
#
sprintf("El periodo correspondiente es aproximadamente: %s",1/Periodograma$freq[ubicacionDif])
```

Para la serie diferenciada el periodograma no es claro, a pesar del suviazamiento usado la curva sigue mostrando varios picos en su recorrido el máximo lo encontramos de tal manera que $\omega = \frac{251}{625}=0.416$ lo cual se corresponde con un $s \approx 2.5$ .

```{r}
# intentando sacar el segundo más alto
n_dld <- length(Periodograma$spec)
valor_seg <- sort(Periodograma$spec,partial=n_dld-1)[n_dld-1]
ubica_segundo <- which(Periodograma$spec==valor_seg)

sprintf("El valor de la frecuencia donde se alcanza el segundo máximo para el periodograma para REC es: %s",Periodograma$freq[ubica_segundo])
#
sprintf("El periodo correspondiente es aproximadamente: %s",1/Periodograma$freq[ubica_segundo])
```

vemos que el segundo valor es bastante parecido al segundo.

```{r}
# valor de frecuencia 
tail(sort(Periodograma$spec))
```

Cómo se puede observar los primeros seis valores son bastante cercanos entre ellos, lo cual deja dudas de si en realidad tenemos un comportamiento ciclico.
